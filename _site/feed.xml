<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SHL</title>
    <description>在学习DL性能优化的学生</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 19 Sep 2018 12:40:55 +0800</pubDate>
    <lastBuildDate>Wed, 19 Sep 2018 12:40:55 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>Docker使用</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近了解到了docker，才发现原来世界上还有这么好用的东西。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;docker的方便之处&quot;&gt;Docker的方便之处&lt;/h3&gt;

&lt;p&gt;从事linux嵌入式开发或者深度学习方向的研究人员往往都会遇到这样一个问题—-服务器的环境配置。linux嵌入式开发需要配置交叉编译所需要的工具，而深度学习研究有各种各样的框架，并且这些框架有概率是互不兼容的（比如说有些论文实现依托于cudnn5.1，而有些则需要更高的版本），总不能为了搭一个环境而舍弃另一个环境吧。&lt;/p&gt;

&lt;p&gt;当服务器环境越配越多，此时，Docker的优势就体现出来了，Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。&lt;/p&gt;

&lt;p&gt;并且，Docker在迁移时更加方便，它没有其他依赖，可以说自己就是一个微型系统。&lt;/p&gt;

&lt;h3 id=&quot;docker使用介绍&quot;&gt;Docker使用介绍&lt;/h3&gt;

&lt;p&gt;docker中有镜像(image)和容器(container)的概念，镜像就是指已经打包好的容器，可以被pull或push的，而容器则是你正在使用的，已经实例化的镜像。&lt;/p&gt;

&lt;p&gt;一般将镜像视为模版，不存放任何代码，只配置环境，代码使用volume挂载放入容器。(&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;时用&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;来挂载)&lt;/p&gt;

&lt;h2 id=&quot;docker常用命令&quot;&gt;docker常用命令&lt;/h2&gt;

&lt;h4 id=&quot;docker-images&quot;&gt;docker images&lt;/h4&gt;

&lt;p&gt;显示已有镜像&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker images
REPOSITORY     TAG         IMAGE ID        CREATED           SIZE
ubuntu        16.04      52b10959e8aa    12 days ago         115MB
ubuntu        14.04      8789038981bc    12 days ago         188MB
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;docker-rmi&quot;&gt;docker rmi&lt;/h4&gt;

&lt;p&gt;删除镜像&lt;/p&gt;

&lt;h4 id=&quot;docker-system-prune--a&quot;&gt;docker system prune -a&lt;/h4&gt;

&lt;p&gt;释放空间&lt;/p&gt;

&lt;h4 id=&quot;docker-ps--a&quot;&gt;docker ps -a&lt;/h4&gt;

&lt;p&gt;显示所有容器&lt;/p&gt;

&lt;h4 id=&quot;docker-start&quot;&gt;docker start&lt;/h4&gt;

&lt;p&gt;在退出容器后需要先start才可以进入。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker start nnie
nnie
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;docker-attach&quot;&gt;docker attach&lt;/h4&gt;

&lt;p&gt;容器开启后使用该命令进入容器。&lt;/p&gt;

&lt;h4 id=&quot;docker-run&quot;&gt;docker run&lt;/h4&gt;

&lt;p&gt;语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一般常用&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -t -i -v /YOUR/PATH:/root/ ImageName /bin/bash&lt;/code&gt;
&lt;strong&gt;注意&lt;/strong&gt;，挂载时要使用绝对路径。&lt;/p&gt;

&lt;p&gt;OPTIONS说明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；

-d: 后台运行容器，并返回容器ID；

-i: 以交互模式运行容器，通常与 -t 同时使用；

-p: 端口映射，格式为：主机(宿主)端口:容器端口

-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；

--name=&quot;nginx-lb&quot;: 为容器指定一个名称；

--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；

--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；

-h &quot;mars&quot;: 指定容器的hostname；

-e username=&quot;ritchie&quot;: 设置环境变量；

--env-file=[]: 从指定文件读入环境变量；

--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；

-m :设置容器使用内存最大值；

--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；

--link=[]: 添加链接到另一个容器；

--expose=[]: 开放一个端口或一组端口；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;docker常用构建方法&quot;&gt;Docker常用构建方法&lt;/h3&gt;

&lt;p&gt;docker hub一般都有许多镜像提供给你直接拉取，如果刚好有你需要的，只要直接pull就可以了。
比如说我需要一个caffe的环境，那么我直接在docker hub上找到&lt;a href=&quot;https://hub.docker.com/r/bvlc/caffe/&quot;&gt;caffe&lt;/a&gt;，然后根据所需要的tag直接拉取镜像就可以了。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 这里我拉取的是caffe的cpu版本&lt;/span&gt;
docker pull bvlc/caffe:cpu

&lt;span class=&quot;c&quot;&gt;# 通过下面这行命令就可以通过拉取的镜像生成自己的容器，并进入到容器中了&lt;/span&gt;
docker run -it bvlc/caffe:cpu /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过主流的可能还是使用DockerFile来构建镜像，DockerFile的优点如下，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dockerfile是Docker镜像的自动化脚本&lt;/li&gt;
  &lt;li&gt;手动图像创build将变得复杂，当你想testing相同的设置不同的操作系统风格，那么你必须创build所有风格的图像，但通过在dockerfile中的小改变，你可以创build不同的风味的图像&lt;/li&gt;
  &lt;li&gt;它具有简单的图像语法，并自动做许多更改，手动将需要更多的时间。&lt;/li&gt;
  &lt;li&gt;Dockerfile有一个系统的步骤，可以让别人很容易理解，并且很容易知道在基本映像中改变了什么确切的configuration。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 18 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/docker/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/docker/</guid>
        
        <category>深度学习</category>
        
        
      </item>
    
      <item>
        <title>C++代码优化</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;  相对于其他简单的高级语言来说，C++可以更好地发挥硬件性能，但就算是相同的算法，代码写的不好，C++也不一定比其他语言就快很多。一般来说，没有一种简单的方法可以完美优化所有情况，所以优化只是尽可能接近最完美的情况。&lt;/p&gt;

&lt;p&gt;  一般优化过程中有两个标准：&lt;br /&gt;
-Principle of diminishing returns.  先从耗时耗力少且优化效果好的部分开始着手优化。&lt;br /&gt;
-Principle of diminishing portability.  先从跨平台通用的代码开始优化。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;

&lt;h5 id=&quot;optimizing-c&quot;&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Optimizing_C%2B%2B&quot;&gt;optimizing C++&lt;/a&gt;&lt;/h5&gt;
</description>
        <pubDate>Tue, 19 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/optimizing-cpp/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/optimizing-cpp/</guid>
        
        <category>性能优化</category>
        
        
      </item>
    
      <item>
        <title>optimization（一）</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;  为什么需要做性能优化？因为深度学习需要大量的计算力，而嵌入式平台不像云端服务器平台一样有超额算力，嵌入式平台需要各种抠细节来充分发挥其性能以勉强提供计算能力。现有许多框架（仍在持续更新）提供给嵌入式平台加速，如&lt;a href=&quot;https://github.com/Tencent/ncnn&quot;&gt;ncnn&lt;/a&gt;，&lt;a href=&quot;https://github.com/ARM-software/ComputeLibrary&quot;&gt;ARM Compute Library&lt;/a&gt;等。&lt;/p&gt;

&lt;p&gt;  一般CNN性能优化的方向有下面几种。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;算法层面的优化
    &lt;ul&gt;
      &lt;li&gt;模型优化&lt;/li&gt;
      &lt;li&gt;卷积计算优化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;系统层面的优化
    &lt;ul&gt;
      &lt;li&gt;代码冗余优化&lt;/li&gt;
      &lt;li&gt;内存优化&lt;/li&gt;
      &lt;li&gt;并行计算&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  算法层面的优化需要太多的数学基础，对做工程的我们来说太难了，只能等业界大佬的论文。模型的优化现在很多大佬都在做，现在主要用mobilenet，shufflenet等轻量模型做主干特征提取网络，还有用剪枝的操作来减少模型参数。&lt;br /&gt;
  卷积计算的优化主要有两种方法，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;im2col: 目前几乎所有的主流计算框架包括Caffe, MXNet等都实现了该方法。该方法把卷积变成矩阵和矩阵的乘法，然后通过各种BLAS库来计算，因为BLAS库优化的非常好，所以这个方法速度是比较快的。&lt;/li&gt;
  &lt;li&gt;winograd: 由于乘法和加法在硬件实现上的时间复杂度一般是不一样的，乘法运算所需的时间通常远大于加法所需的时间。因此，用廉价运算代替昂贵运算也是加速运算。winograd就是通过变换来用加法来替换部分乘法以达到优化增速的目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  对于工程师而言，主要是针对系统级的优化，需要考虑&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;代码是否有冗余&lt;/li&gt;
  &lt;li&gt;代码是否缓存友好&lt;/li&gt;
  &lt;li&gt;内存重要还是速度重要&lt;/li&gt;
  &lt;li&gt;是否有多核可以利用&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;im2colgemm&quot;&gt;im2col+gemm&lt;/h3&gt;

&lt;p&gt;  我这里就先&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/optimization/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/optimization/</guid>
        
        <category>性能优化</category>
        
        
      </item>
    
      <item>
        <title>Winograd for CNN（二）</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;  winograd通过用加法代替乘法来加速运算，其需要预设部分矩阵来帮助计算，但矩阵的选择也是各有千秋，具体要如何选择大家可以网上搜索。算法对于不同的矩阵有着不同的速度和效果。而现在也有许多不同的winograd算法实现，我这里主要基于&lt;code class=&quot;highlighter-rouge&quot;&gt;Fast Algorithms for Convolutional Neural Networks&lt;/code&gt;的&lt;script type=&quot;math/tex&quot;&gt;F(2\times 2, 3\times 3)&lt;/script&gt;实现。&lt;/p&gt;

&lt;p&gt;  我这里只是粗略的实现了一下效果，代码就写的很简陋(￣▽￣)。&lt;/p&gt;

&lt;h3 id=&quot;代码示例&quot;&gt;代码示例&lt;/h3&gt;

&lt;p&gt;  这里我设置&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
G=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0.5 &amp; 0.5 &amp; 0.5 \\ 0.5&amp;-0.5&amp;0.5\\0&amp;0&amp;1\end{bmatrix} %]]&gt;&lt;/script&gt;,&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
B^T=\begin{bmatrix} 1 &amp; 0 &amp; -1&amp;0 \\ 0 &amp;1 &amp; 1&amp;0 \\ 0&amp;-1&amp;1&amp;0\\0&amp;1&amp;0&amp;-1\end{bmatrix} %]]&gt;&lt;/script&gt;,&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A^T=\begin{bmatrix} 1&amp; \quad1 &amp;\quad1&amp;\quad0\\0&amp;\quad1&amp;-1&amp;-1\end{bmatrix} %]]&gt;&lt;/script&gt;。以&lt;script type=&quot;math/tex&quot;&gt;4\times 4&lt;/script&gt;的输入，&lt;script type=&quot;math/tex&quot;&gt;3\times 3&lt;/script&gt;的卷积核为例。（注意输入是要加padding的）&lt;/p&gt;

&lt;h2 id=&quot;gggt&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;GgG^T&lt;/script&gt;&lt;/h2&gt;

&lt;p&gt;  这一步对于同一个卷积核的值来说是固定，因此是可以提前计算好的，是offline的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;float **U_2x2_3x3(float *kernel)
{
    float G[4][3] = { { 1,    0,    0},
                      {0.5,  0.5,  0.5},
                      {0.5, -0.5,  0.5},
                      { 0,    0,    1} };
    float GT[3][4] = { { 1,  0.5,  0.5,  0},
                       { 0,  0.5, -0.5,  0},
                       { 0,  0.5,  0.5,  1} };
    
    float G_g[4][3] = {0};
    for (int i = 0; i &amp;lt; 4; ++i) {
        for (int j = 0; j &amp;lt; 3; ++j) {
            float temp = 0;
            for (int k = 0; k &amp;lt; 3; ++k) {
                temp += G[i][k] * kernel[k * 3 + j];
            }
            G_g[i][j] = temp;
        }
    }

    float **G_g_GT;
    G_g_GT = (float**)malloc(4 * sizeof(float*));
    //float G_g_GT[4][4] = {0};
    for (int i = 0; i &amp;lt; 4; ++i) {
        G_g_GT[i] = (float*)malloc(4 * sizeof(float));
        memset(G_g_GT[i], 0, 4 * sizeof(float));
        for (int j = 0; j &amp;lt; 4; ++j) {
            float temp = 0;
            for (int k = 0; k &amp;lt; 3; ++k) {
                temp += G_g[i][k] * GT[k][j];
            }
            G_g_GT[i][j] = temp;
        }
    }

    return G_g_GT;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;btdb&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;B^TdB&lt;/script&gt;&lt;/h2&gt;

&lt;p&gt;  因为我预设的输入是用一维数组来表示二维的矩阵，所以需要一个矩阵起始位置来推断分割的矩阵。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;float **V_2x2_3x3(float *input, int start)
{
    int BT[4][4] = { {1,  0, -1,  0},
                     {0,  1,  1,  0},
                     {0, -1,  1,  0},
                     {0,  1,  0, -1}};
    int B[4][4] =  { { 1,  0,  0,  0},
                     { 0,  1, -1,  1},
                     {-1,  1,  1,  0},
                     { 0,  0,  0, -1}};

    float BT_d[4][4] = {0};
    for (int i = 0; i &amp;lt; 4; ++i) {
        for (int j = 0; j &amp;lt; 4; ++j) {
            float temp = 0;
            for (int k = 0; k &amp;lt; 4; ++k) {
                temp += BT[i][k] * input[k * 6 + j + start];
            }
            BT_d[i][j] = temp;
        }
    }

    float **BT_d_B;
    BT_d_B = (float**)malloc(4 * sizeof(float*));
    //float BT_d_B[4][4] = {0};
    for (int i = 0; i &amp;lt; 4; ++i) {
        BT_d_B[i] = (float*)malloc(4 * sizeof(float));
        memset(BT_d_B[i], 0, 4 * sizeof(float));
        for (int j = 0; j &amp;lt; 4; ++j) {
            float temp = 0;
            for (int k = 0; k &amp;lt; 4; ++k) {
                temp += BT_d[i][k] * B[k][j];
            }
            BT_d_B[i][j] = temp;
        }
    }

    return BT_d_B;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;atuodot-va&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;A^T[U\odot V]A&lt;/script&gt;&lt;/h2&gt;

&lt;p&gt;  这里输出的就是局部的最终结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;float **M_2x2_3x3(float **U, float **V)
{
    int AT[2][4] = { {1, 1,  1,  0},
                     {0, 1, -1, -1} };

    int A[4][2] = { {1,  0},
                    {1,  1},
                    {1, -1},
                    {0, -1} };

    float M[4][4] = {0};
    for (int i = 0; i &amp;lt; 4; ++i) {
        for (int j = 0; j &amp;lt; 4; ++j) {
            M[i][j] = U[i][j] * V[i][j];
        }
    }

    for (int l = 0; l &amp;lt; 4; ++l) {
        free(V[l]);
    }
    free(V);

    float AT_M[2][4] = {0};
    for (int i = 0; i &amp;lt; 2; ++i) {
        for (int j = 0; j &amp;lt; 4; ++j) {
            float temp = 0;
            for (int k = 0; k &amp;lt; 4; ++k) {
                temp += AT[i][k] * M[k][j];
            }
            AT_M[i][j] = temp;
        }
    }

    float **AT_M_A;
    AT_M_A = (float**)malloc(2 * sizeof(float*));
    for (int i = 0; i &amp;lt; 2; ++i) {
        AT_M_A[i] = (float*)malloc(2 * sizeof(float));
        memset(AT_M_A[i], 0, 2 * sizeof(float));
        for (int j = 0; j &amp;lt; 2; ++j) {
            float temp = 0;
            for (int k = 0; k &amp;lt; 4; ++k) {
                temp += AT_M[i][k] * A[k][j];
            }
            AT_M_A[i][j] = temp;
        }
    }

    return AT_M_A;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;winograd&quot;&gt;Winograd&lt;/h2&gt;

&lt;p&gt;  因为我这里举的输入是&lt;script type=&quot;math/tex&quot;&gt;4\times 4&lt;/script&gt;，卷积为&lt;script type=&quot;math/tex&quot;&gt;3\times 3&lt;/script&gt;的例子，所以局部结果可以刚好拼成最终结果，而且padding也只要上下左右各加1就可以了。但如果是&lt;script type=&quot;math/tex&quot;&gt;7\times 7&lt;/script&gt;的输入，那么padding在下面和右边都要加2才行，而且在局部结果拼最终结果时要舍去1行和1列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void winograd(float* input, float* kernel, float* output, int input_size)
{
    float **U;
    U = U_2x2_3x3(kernel);
    for (int l = 0; l &amp;lt; 2; ++l) {      //  H/m向上取整
        for (int n = 0; n &amp;lt; 2; ++n) {
            float **V, **Y;
            V = V_2x2_3x3(input, l * input_size * 2 + n * 2);
            Y = M_2x2_3x3(U, V);
            int row_col = l * 8 + n * 2;
            memcpy(output + row_col, Y[0], 2 * sizeof(float));
            memcpy(output + row_col + 4, Y[1], 2 * sizeof(float));

        }
    }
    for (int i = 0; i &amp;lt; 4; ++i) {
        free(U[i]);
    }
    free(U);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;剩余代码&quot;&gt;剩余代码&lt;/h2&gt;

&lt;p&gt;  全部代码都在这里了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void mm(float* input, float* kernel, float* output, int input_size, int kernel_size)
{
    int output_size = input_size - kernel_size + 1;
    for (int i = 0; i &amp;lt; output_size; ++i) {
        for (int j = 0; j &amp;lt; output_size; ++j) {
            float temp = 0;
            for (int k = 0; k &amp;lt; kernel_size; ++k) {
                for (int l = 0; l &amp;lt; kernel_size; ++l) {
                    temp += kernel[k*kernel_size+l] * input[i*input_size+j+k*input_size+l];
                }
            }
            output[i*output_size + j] = temp;
        }
    }
}

int main() {
    int input_size, kernel_size;
    input_size = 4;
    kernel_size = 3;
    float *input, *kernel, *output, *winograd_out;
    input = (float*)malloc(input_size * input_size * sizeof(float));
    for (int i = 0; i &amp;lt; input_size*input_size; ++i) {
        input[i] = i;
    }

    input = add_padding(input,input_size);
    input_size += 2;

    kernel = (float*)malloc(kernel_size * kernel_size * sizeof(float));
    for (int i = 0; i &amp;lt; kernel_size*kernel_size; ++i) {
        kernel[i] = 1;
    }

    int output_size = input_size;
    output = (float*)malloc(output_size * output_size * sizeof(float));
    memset(output, 0, output_size * output_size * sizeof(float));
    winograd_out = (float*)malloc(output_size * output_size * sizeof(float));
    memset(winograd_out, 0, output_size * output_size * sizeof(float));
    clock_t start, end1, end2;

    start = clock();
    mm(input, kernel, output, input_size, kernel_size);

    end1 = clock();
    winograd(input, kernel, winograd_out, input_size);
    end2 = clock();

    printf(&quot;mm cost %f , winograd cost %f&quot;, double(end1-start)/CLOCKS_PER_SEC, double(end2-end1)/CLOCKS_PER_SEC);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;  虽然结果是一样的，但是我实现的winograd比寻常卷积要慢好多╮(￣▽￣””)╭。具体原因应该还要我接下来摸索，应该可以考虑内存池优化、汇编优化、代码消冗余等。&lt;/p&gt;

</description>
        <pubDate>Tue, 05 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/winograd2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/winograd2/</guid>
        
        <category>深度学习</category>
        
        <category>性能优化</category>
        
        
      </item>
    
      <item>
        <title>Winograd for CNN（一）</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;  虽然现在深度卷积神经网络在计算机视觉领域表现的非常优秀，但它在大型数据集上训练时需要花费大量GPU计算时间，并且前向推理需要大量的计算力。我们希望深度卷积网络可以在嵌入式平台部署，并且希望在保证精度的情况下加快它的推理速度。常规的基于FFT的卷积对于大型滤波器是快速的，但是现有技术的卷积神经网络一般使用小的3×3滤波器。论文引入了基于Winograd的最小滤波算法，一种新的卷积神经网络快速算法。算法在小卷积上计算复杂度最小，这使得它在滤波器和batch小的情况下更快。论文使用VGG网络对算法的GPU实现进行基准测试，并展示了批处理大小从1到64的时时吞吐量。[1]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cong和Xiao使用Strassen算法进行快速矩阵乘法，以减少卷积网络层中的调度次数，从而降低其总算术复杂度。 作者还提出，来自算术复杂性理论的更多技术可能适用于衔接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  原始的Winograd算法，前置了很多数论方面的知识，为了效率我就没有深入的去阅读了。本文主要针对阅读了&lt;code class=&quot;highlighter-rouge&quot;&gt;Fast Algorithms for Convolutional Neural Networks&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;卷积公式&quot;&gt;卷积公式&lt;/h3&gt;

&lt;p&gt;  假设卷积为G，图像为D，输入参数数量N，通道C，高H，宽W &lt;br /&gt;
卷积核参数通道C，高R，宽S，则卷积公式如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex1.png&quot; alt=&quot;&quot; height=&quot;40%&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  我们可以将整个图像的输出写作（其中*指代2D相关性）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex2.png&quot; alt=&quot;&quot; height=&quot;20%&quot; width=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;算法&quot;&gt;算法&lt;/h3&gt;

&lt;p&gt;  假设用长度为r的FIR滤波器来得到输出m的式子为&lt;script type=&quot;math/tex&quot;&gt;F(m, r)&lt;/script&gt;，传统的winograd算法需要&lt;script type=&quot;math/tex&quot;&gt;µ(F(m,r)) = m + r - 1&lt;/script&gt;次乘法。我们可以通过堆叠一维算法来得到二维的最小算法——假设&lt;script type=&quot;math/tex&quot;&gt;F(m\times n, r\times s)&lt;/script&gt;指代用&lt;script type=&quot;math/tex&quot;&gt;r\times s&lt;/script&gt;的滤波器来计算得到&lt;script type=&quot;math/tex&quot;&gt;m\times n&lt;/script&gt;的输出，则它需要
&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex3.png&quot; alt=&quot;&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;
次乘法。以此为例，我们可以继续堆叠一维算法来得到多维的最小算法。&lt;br /&gt;
  &lt;strong&gt;&lt;font color=&quot;red&quot;&gt;但是需要注意不管是一维、二维还是多维的最快计算法，它要求输入的数量与所需乘法数一样。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;f2times-23times-3&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;F(2\times 2,3\times 3)&lt;/script&gt;&lt;/h2&gt;

&lt;p&gt;  我们知道，乘法和加法在硬件实现上的时间复杂度一般是不一样的，乘法运算所需的时间通常远大于加法所需的时间。因此，用廉价运算代替昂贵运算也是加速运算的一种方法。原始的矩阵运算对于&lt;script type=&quot;math/tex&quot;&gt;F(2,3)&lt;/script&gt;需要6次乘法，而Winograd提出了如下算法，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex4.png&quot; alt=&quot;&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;
  其中，
&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex5.png&quot; alt=&quot;&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  该算法只用了&lt;script type=&quot;math/tex&quot;&gt;2+3-1=4&lt;/script&gt;个乘法就计算得到了&lt;script type=&quot;math/tex&quot;&gt;F(2,3)&lt;/script&gt;，不过它涉及了4个与输入数据有关的加法，还有与常数滤波器有关的3个加法（&lt;script type=&quot;math/tex&quot;&gt;g_0+g_2&lt;/script&gt;只要算一次就行了）和2个乘法（因为滤波器为常数，所以这3个加法和2个乘法可以认为不占用时间）。&lt;/p&gt;

&lt;p&gt;  我们可以将矩阵公式写成
&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex6.png&quot; alt=&quot;&quot; height=&quot;30%&quot; width=&quot;30%&quot; /&gt;
  其中，&lt;script type=&quot;math/tex&quot;&gt;\odot&lt;/script&gt;指逐元素的乘法（就是点乘，卷积用的）。对于&lt;script type=&quot;math/tex&quot;&gt;F(2,3)&lt;/script&gt;而言，上述公式各元素表示的意义如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex7.png&quot; alt=&quot;&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  堆叠一维算法可以得到二维算法&lt;script type=&quot;math/tex&quot;&gt;F(m\times m, r\times r)&lt;/script&gt;如下（这一步论文没有具体的分析，不是很懂为什么，估计是各种线性变换(￣▽￣) ）
&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex8.png&quot; alt=&quot;&quot; height=&quot;30%&quot; width=&quot;30%&quot; /&gt;
  其中，&lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;是一个&lt;script type=&quot;math/tex&quot;&gt;r\times r&lt;/script&gt;的滤波器，&lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;是一个&lt;script type=&quot;math/tex&quot;&gt;(m+r-1)\times(m+r-1)&lt;/script&gt;的输入图像块。&lt;/p&gt;

&lt;p&gt;  &lt;script type=&quot;math/tex&quot;&gt;F(2\times 2, 3\times 3)&lt;/script&gt;用winograd只需要&lt;script type=&quot;math/tex&quot;&gt;4\times 4=16&lt;/script&gt;次乘法，而原始矩阵运算则需要&lt;script type=&quot;math/tex&quot;&gt;2\times 2\times 3\times 3=36&lt;/script&gt;次乘法运算。尽管winograd法还需要用32次加法来进行数据转换，用28个浮点运算指令来进行滤波器转换，用24次加法来进行反转变换，但是相比原始矩阵运算法还是提升很大。&lt;/p&gt;

&lt;p&gt;  &lt;script type=&quot;math/tex&quot;&gt;F(2\times 2,3\times 3)&lt;/script&gt;可以被用来计算卷积核为&lt;script type=&quot;math/tex&quot;&gt;r\times r&lt;/script&gt;的卷积操作。其中，输入图像的每个通道需要被切割成&lt;script type=&quot;math/tex&quot;&gt;(m+r-1)\times(m+r-1)&lt;/script&gt;大小的块（每个块与相邻块间有&lt;script type=&quot;math/tex&quot;&gt;r-1&lt;/script&gt;的重叠区域），则每个通道可以有&lt;script type=&quot;math/tex&quot;&gt;P=\left\lceil H/m\right\rceil\times\left\lceil W/m\right\rceil&lt;/script&gt;个块。然后&lt;script type=&quot;math/tex&quot;&gt;F(2\times 2,3\times 3)&lt;/script&gt;可以分别计算所有块然后累加得到最终结果。&lt;/p&gt;

&lt;p&gt;  假设&lt;script type=&quot;math/tex&quot;&gt;U=G_gG^T&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;V=B^{T}dB&lt;/script&gt;，则
&lt;script type=&quot;math/tex&quot;&gt;Y=A^{T}[U\odot V]A&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;  以&lt;script type=&quot;math/tex&quot;&gt;(\widetilde {x},\widetilde {y})&lt;/script&gt;为各个块坐标，&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;指单张图片，&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;为滤波器，则可以将上述卷积公式改写成，
&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex11.png&quot; alt=&quot;&quot; height=&quot;40%&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  以下是具体实现的伪代码&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex12.png&quot; alt=&quot;&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  论文接下来的算法介绍主要提供了&lt;script type=&quot;math/tex&quot;&gt;F(3\times 3,2\times 2)&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;F(4\times 4,3\times 3)&lt;/script&gt;的&lt;script type=&quot;math/tex&quot;&gt;A,G,B&lt;/script&gt;矩阵。&lt;/p&gt;

&lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;

&lt;p&gt;  下面这个公式是最重要的一块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-05-31-Winograd/tex8.png&quot; alt=&quot;&quot; height=&quot;30%&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;A,G,B&lt;/script&gt;根据不同的卷积核有不同的值，而且是提前计算好的，可以用&lt;a href=&quot;https://github.com/andravin/wincnn&quot;&gt;https://github.com/andravin/wincnn&lt;/a&gt;的脚本计算。不过，&lt;script type=&quot;math/tex&quot;&gt;A,G,B&lt;/script&gt;也不是可以通过脚本直接得到的，还需要自己确定&lt;script type=&quot;math/tex&quot;&gt;m+r-2&lt;/script&gt;个插值点，wincnn的作者推荐了&lt;a href=&quot;https://openreview.net/forum?id=H1ZaRZVKg&amp;amp;noteId=H1ZaRZVKg&quot;&gt;https://openreview.net/forum?id=H1ZaRZVKg&amp;amp;noteId=H1ZaRZVKg&lt;/a&gt;可以帮助确定插值点。（感觉好难啊（−＿−；））&lt;/p&gt;

&lt;p&gt;  自己推了好久，发现根本就没办法算，之后只能找代码看（&lt;a href=&quot;https://github.com/NervanaSystems/neon/blob/master/neon/backends/winograd.py&quot;&gt;winograd.py&lt;/a&gt;），原来winograd是一定要加padding补全的，加多少padding视情况而定。所以其实这个算法就是针对卷积套公式，不过卷积计算选择不同算法，速度会不太一样。（现在有许多版本的winograd）&lt;/p&gt;

&lt;p&gt;  对于不同的输入用不同的padding补全，最后会选择性地舍弃部分数据。如&lt;script type=&quot;math/tex&quot;&gt;7\times 7&lt;/script&gt;的输入，在用&lt;script type=&quot;math/tex&quot;&gt;F(2\times 2, 3\times 3)&lt;/script&gt;计算时，会在左边补一个padding，在右边补两个padding，最后winograd卷积得到一个&lt;script type=&quot;math/tex&quot;&gt;8\times 8&lt;/script&gt;的输出，这时就要舍弃最右边的一列。&lt;/p&gt;

&lt;p&gt;  我尝试写了一下自己版本的winograd算法，以便后面学习优化，具体可以看&lt;a href=&quot;/2018/06/winograd2&quot;&gt;下一篇&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;

&lt;h5 id=&quot;1-lavin-a-gray-s-fast-algorithms-for-convolutional-neural-networkscproceedings-of-the-ieee-conference-on-computer-vision-and-pattern-recognition-2016-4013-4021&quot;&gt;1. Lavin A, Gray S. &lt;a href=&quot;https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Lavin_Fast_Algorithms_for_CVPR_2016_paper.pdf&quot;&gt;Fast algorithms for convolutional neural networks[C]&lt;/a&gt;//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2016: 4013-4021.&lt;/h5&gt;

&lt;h5 id=&quot;2-winograd-方法快速计算卷积&quot;&gt;2. &lt;a href=&quot;http://shuokay.com/2018/02/21/winograd/&quot;&gt;Winograd 方法快速计算卷积&lt;/a&gt;&lt;/h5&gt;

&lt;h5 id=&quot;3-知乎如何通俗易懂地解释卷积&quot;&gt;3. &lt;a href=&quot;https://www.zhihu.com/question/22298352&quot;&gt;知乎，如何通俗易懂地解释卷积？&lt;/a&gt;&lt;/h5&gt;
</description>
        <pubDate>Thu, 31 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/winograd/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/winograd/</guid>
        
        <category>深度学习</category>
        
        <category>性能优化</category>
        
        
      </item>
    
      <item>
        <title>Pytorch自定义Loss函数</title>
        <description>&lt;p&gt;  Pytorch定义自己的loss函数十分方便，有很多方法可以选择。&lt;/p&gt;

&lt;h3 id=&quot;只定义loss函数的前向计算公式&quot;&gt;只定义loss函数的前向计算公式&lt;/h3&gt;

&lt;p&gt;  在pytorch中定义了前向计算的公式，在训练时它会自动帮你计算反向传播。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch.nn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;nn&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;YourLoss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;自定义loss函数的forward和backward&quot;&gt;自定义loss函数的forward和backward&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy.fft&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rfft2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irfft2&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BadFFTFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;numpy_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rfft2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;backward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grad_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;numpy_go&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grad_output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irfft2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy_go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grad_output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;自己写一个pytorch的c扩展&quot;&gt;自己写一个pytorch的C扩展&lt;/h3&gt;

&lt;p&gt;  这个了解不多，所以也不太会&lt;/p&gt;

&lt;h3 id=&quot;简单定义&quot;&gt;简单定义&lt;/h3&gt;

&lt;p&gt;  看网上有说直接定义一个简单函数就可以了，可以尝试一下，与只定义forward类似。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;......&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#模型操作&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 21 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/pytorch_loss/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/pytorch_loss/</guid>
        
        <category>pytorch</category>
        
        
      </item>
    
      <item>
        <title>TextBoxes++使用SynthText数据集</title>
        <description>&lt;h3 id=&quot;synthtext数据集&quot;&gt;SynthText数据集&lt;/h3&gt;

&lt;p&gt;  SynthText(synthetic text)其实是指用代码合成的文本图像数据，它的源码在https://github.com/ankush-me/SynthText，如果有需要你可以用它的源码来合成自己的文本训练集。我们这里使用的是用这种方法得到的官方提供&lt;a href=&quot;http://www.robots.ox.ac.uk/~vgg/data/scenetext/&quot;&gt;数据集SynthText&lt;/a&gt;，这个数据集包含了80万张图像，其中融入了800万个文本。&lt;/p&gt;

&lt;h3 id=&quot;数据格式转成适用于textboxes的xml格式&quot;&gt;数据格式转成适用于TextBoxes++的xml格式&lt;/h3&gt;

&lt;p&gt;  有许多语言可以读取并处理mat格式文件，我在这里选用python来处理。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 读取gt.mat数据&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scipy.io&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sio&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loadmat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'gt.mat'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  之前我直接用string来规范文本数据，但是并不如xml包来的好管理。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scipy.io&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sio&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;np&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;xml.dom.minidom&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MatRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loadmat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'train.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'w'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'test.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'w'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;No.{} data&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'wordBB'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transpose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transpose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newaxis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;minidom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'annotation'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;start to process {} object&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nodeobject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'object'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nodecontent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'content'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nodecontent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createTextNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])))&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;nodename&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'name'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nodename&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createTextNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'text'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xmin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xmax'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ymin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ymax'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;nodebndbox&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'bndbox'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nodecoord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nodecoord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createTextNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nodebndbox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodecoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;nodeobject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodecontent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nodeobject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nodeobject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodebndbox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeobject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'imnames'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'.jpg'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'.xml'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'w'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writexml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addindent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uniform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getcwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;img_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'imnames'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xml_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;file_line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xml_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    

    &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;生成lmdb数据&quot;&gt;生成lmdb数据&lt;/h3&gt;

&lt;p&gt;  将&lt;code class=&quot;highlighter-rouge&quot;&gt;train.txt&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;test.txt&lt;/code&gt;移到&lt;code class=&quot;highlighter-rouge&quot;&gt;TextBoxes_plusplus/data/text&lt;/code&gt;目录下，再执行&lt;code class=&quot;highlighter-rouge&quot;&gt;./create_data.sh&lt;/code&gt;即可得到lmdb文件。&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/SynthText/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/SynthText/</guid>
        
        <category>深度学习</category>
        
        
      </item>
    
      <item>
        <title>TextBoxe++的VGGnet用Mobilenet替换</title>
        <description>&lt;p&gt;  现在一般的检测网络都会用VggNet来作骨架，而Vgg网络的体量有点大，不太适合嵌入式实现。Mobilenet是google提出的一个轻量网络，可以在保持较高精度的同时极大地降低网络运算量，因此Mobilenet就成了在嵌入式设备上实现深度学习的首选。&lt;/p&gt;

&lt;p&gt;  由于TextBoxes使用的是pycaffe来生成网络，所以我也基于pycaffe来生成Mobilenet的网络，对照&lt;code class=&quot;highlighter-rouge&quot;&gt;./python/caffe/model_libs&lt;/code&gt;下的VGGNetBody来写我自己的MobileNet。因为原始的ConvBNlayer没有添加group参数，所以需要自己来添加，并且还需要添加engine参数。&lt;/p&gt;

&lt;p&gt;  Caffe中用group来实现Mobilenet的深度可分离卷积，速度比较慢，并且其CUDNN似乎不太支持，需要使用CAFFE engine。否则会报Check failed: status == CUDNN_STATUS_SUCCESS (4 vs. 0)，刚开始我以为是内存不足，但我一直将batch_size减小到1都不行，所以去网上查找资料，然后发现并解决了这个问题。&lt;/p&gt;

&lt;p&gt;  直接开始测试，报错Check failed: shape[i] &amp;gt;= 0 (-1 vs. 0)。&lt;/p&gt;

&lt;p&gt;  显然这是卷积到最后卷不下去了（stride！=1的情况下一般会缩小feature map）。所以我先尝试着将input_size调大，这样可以多卷几次。将input_size从384调整搭到768，可以实现训练，不过这和我们想的加速不太符合，因为输入变大，需要处理的数据也就变多了。那就只能修改网络的结构了，虽然不知道这样做好不好，但还是先改了吧，我将最后几层的pad改成1，这样可以让卷积可以卷1x1的feature map。&lt;/p&gt;

&lt;p&gt;  如果报了Out of memory的错误，那么就是需要处理的数据太多了，要么减少batch_size，要么降低输入的图片分辨率。&lt;/p&gt;

&lt;p&gt;  只用ICDAR2015的数据来训练，效果不是很好。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-04-05-VGG2Mobile/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;最终结果&quot;&gt;最终结果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-04-05-VGG2Mobile/demo_det_result.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  如果你的效果没有那么好，那么可以注意置信度的取值&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/VGG2Mobile/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/VGG2Mobile/</guid>
        
        <category>深度学习</category>
        
        
      </item>
    
      <item>
        <title>对不规则四边形使用nms</title>
        <description>&lt;h3 id=&quot;nms非极大抑制&quot;&gt;nms非极大抑制&lt;/h3&gt;

&lt;p&gt;  非极大值抑制顾名思义就是抑制不是极大值的元素，搜索局部的极大值。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。这里不讨论通用的NMS算法，而是用于在目标检测中用于提取分数最高的窗口的。例如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。&lt;/p&gt;

&lt;h2 id=&quot;iou&quot;&gt;IOU&lt;/h2&gt;

&lt;p&gt;  nms主要是基于一个评价指标，IOU，简单来讲就是模型产生的目标窗口和原来标记窗口的交叠率。具体我们可以简单的理解为： 即检测结果(DetectionResult)与 Ground Truth 的交集比上它们的并集，即为检测的准确率 IoU :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-03-31-compute_iou/formula.jpg&quot; alt=&quot;&quot; height=&quot;40%&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  具体就如下图所示，&lt;code class=&quot;highlighter-rouge&quot;&gt;iou = (area1 + area2) / inter_area&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-03-31-compute_iou/iou.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  矩形的iou很好算，代码也很好写，网上代码很多，就不介绍了。&lt;/p&gt;

&lt;h3 id=&quot;不规则四边形的nms&quot;&gt;不规则四边形的nms&lt;/h3&gt;

&lt;p&gt;  虽然矩形也是四边形，也有四个点，但矩形很特殊。虽然矩形有4个点，但它只有4个值[xmin, xmax, ymin, ymax]，只需要知道这四个值就可以确定一个矩形了。所以对于矩形而言并没有多少情况需要考虑，而四边形不一样，四边形需要8个值，[x1, y1, x2, y2, x3, y3, x4, y4]，所以它的情况比较复杂。&lt;/p&gt;

&lt;h2 id=&quot;四边形iou计算&quot;&gt;四边形IOU计算&lt;/h2&gt;

&lt;p&gt;  首先我们要先知道在已知4个点的坐标情况下，如何计算一个四边形的面积，这里我是将它分成两个三角形然后用公式求解。这个函数当然不只可以求四边形面积，它计算的是多边形的面积。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;typedef struct point_sh{
    int x,y;
    float sina;
    int q;
}Point;

inline int compute_q(std::vector&amp;lt;point_sh&amp;gt;&amp;amp; pt, float x0, float y0)
{
    for (int i=0; i&amp;lt;pt.size(); i++)
    {
        point_sh*p = &amp;amp;pt[i];
        if (p-&amp;gt;x - x0 &amp;gt; 0)
        {
            if (p-&amp;gt;y - y0 &amp;gt; 0)
                p-&amp;gt;q = 1;
            else
                p-&amp;gt;q = 4;
        }
        else
        {
            if (p-&amp;gt;y - y0 &amp;gt; 0)
                p-&amp;gt;q = 2;
            else
                p-&amp;gt;q = 3;        
        }
    }

    return 0;
}

float polygon_area(std::vector&amp;lt;point_sh&amp;gt; pt)
{
    if (pt.size() &amp;lt; 3)
        return -100;

    float x0,y0;
    x0 = (pt[0].x + pt[1].x + pt[2].x) / 3.0;
    y0 = (pt[0].y + pt[1].y + pt[2].y) / 3.0;
    //std::vector&amp;lt;float&amp;gt; sins;
    float dx, dy, ds, sina;
    for (int i=0; i&amp;lt;pt.size(); i++)
    {
        dx = pt[i].x - x0;
        dy = pt[i].y - y0;
        ds = std::sqrt(dx * dx + dy * dy);
        pt[i].sina = dy / ds;
    }

    compute_q(pt, x0, y0);
    //简单排序，如有需要可以优化
    int j=0;
    while(1)
    {
        if (j &amp;gt; pt.size())
            break;

        for (int i=1; i&amp;lt;pt.size(); i++)
        {
            if (pt[j].q &amp;lt; pt[i].q)
                continue;
            
            if (pt[j].q &amp;gt; pt[i].q)
                std::swap(pt[j], pt[i]);
            else if ((pt[j].q == 1 || pt[j].q == 4) &amp;amp;&amp;amp; pt[j].sina &amp;gt; pt[i].sina ||
                     (pt[j].q == 1 || pt[j].q == 4) &amp;amp;&amp;amp; pt[j].sina &amp;lt; pt[i].sina)
                        std::swap(pt[j], pt[i]);
        }
        j++;
    }

    point_sh Fpt = pt[0];
    float area = 0;
    for (int i=1; i&amp;lt;pt.size()-1; i++)
    {
        area += std::fabs(0.5f * (Fpt.x * (pt[i].y - pt[i+1].y) + pt[i].x * (Fpt.y - pt[i].y) + pt[i+1].x * (pt[i+1].y - Fpt.y)));
    }

    return area;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  这样，其实两个四边形的面积就可以直接求出来了，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;area1 + area2&lt;/code&gt;的值，接下来需要找出两个四边形的相交区域的顶点，这部分代码我主要参考了 &lt;a href=&quot;https://www.cnblogs.com/dwdxdy/p/3232110.html&quot;&gt;https://www.cnblogs.com/dwdxdy/p/3232110.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  同理得到顶点集合后直接代入函数即可得到交集面积。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;float polygon_iou(bbox polygon1, bbox polygon2)
{
    float iou, inter_area, area1, area2;
    std::vector&amp;lt;point_sh&amp;gt; ps1, ps2;
    ps1 = poly2point(polygon1);
    ps2 = poly2point(polygon2);
    std::vector&amp;lt;Point&amp;gt; inter_poly;
    if (PolygonClip(ps1, ps2, inter_poly))
    {
        area1 = polygon_area(ps1);
        area2 = polygon_area(ps2);
        inter_area = polygon_area(inter_poly);
        iou = inter_area / (area1 + area2);
    }
    else
        iou = 0;
    return iou;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;nms&quot;&gt;nms&lt;/h2&gt;

&lt;p&gt;  nms的话还是要先根据框的分数(score)来确定一个基准框，然后再计算iou来消除其他的框。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;bool compare(bbox a, bbox b)
{
    return a.score &amp;lt; b.score;
}

static int nms(std::vector&amp;lt;bbox&amp;gt;&amp;amp; polygons, float overlap)
{
    std::sort(polygons.begin(), polygons.end(), compare);
    int j=0;
    while(1)
    {
        bbox Fpolygon = polygons[j];//try..catch
        j++;
        if (j &amp;gt; polygons.size())
            break;
        
        for (int i=j; i&amp;lt;polygons.size(); i++)
        {
            float iou = polygon_iou(Fpolygon, polygons[i]);
            if (iou &amp;gt; overlap)
                polygons.erase(polygons.begin() + i);
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;end&quot;&gt;END&lt;/h2&gt;

&lt;p&gt;  完整的代码可以&lt;a href=&quot;https://github.com/FreshMOU/ncnn/blob/master/examples/ssd/textboxes.cpp&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 31 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/compute_iou_of_quad/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/compute_iou_of_quad/</guid>
        
        <category>深度学习</category>
        
        
      </item>
    
      <item>
        <title>TextBoxes_plusplus基于ncnn实现</title>
        <description>&lt;h3 id=&quot;textboxes_plusplus的实现&quot;&gt;TextBoxes_plusplus的实现&lt;/h3&gt;

&lt;p&gt;  TextBoxes是基于caffe实现的。针对其网络，作者修改了caffe的源码，主要是prior_box层和detection_output层。为了区别普通caffe代码，作者为其添加了两个参数，分别是prior_box层的&lt;code class=&quot;highlighter-rouge&quot;&gt;denser_prior_boxes&lt;/code&gt;和detection_output层的&lt;code class=&quot;highlighter-rouge&quot;&gt;use_polygon&lt;/code&gt;，在这个两个参数下，作者添加了自己的算法代码，所以我们可以通过这部分算法代码来对TextBoxes进行移植。&lt;/p&gt;

&lt;h3 id=&quot;textboxes-caffe模型转ncnn模型&quot;&gt;TextBoxes++ caffe模型转ncnn模型&lt;/h3&gt;

&lt;p&gt;  Ncnn提供了caffe转ncnn的tools  &lt;code class=&quot;highlighter-rouge&quot;&gt;./tools/caffe/caffe2ncnn.cpp&lt;/code&gt;，但是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;denser_prior_boxes&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;use_polygon&lt;/code&gt;是Textboxes_plusplus自己集成的参数，所以ncnn并不支持，这里就要自己去添加了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;找到 else if (layer.type() == &quot;PriorBox&quot;)
在if的末尾添加  fprintf(pp, &quot; 14=%d&quot;, prior_box_param.denser_prior_boxes());
找到 else if (layer.type() == &quot;DetectionOutput&quot;)，在if末尾添加  
fprintf(pp, &quot; 5=%d&quot;, detection_output_param.use_polygon());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  然后编译ncnn&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir build
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;build
cmake ..
make -j4
./tools/caffe/caffe2ncnn your_path_deploy.prototxt your_path_model.caffemodel xxx.param xxx.bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  这样caffe模型就顺利的转成ncnn模型(&lt;code class=&quot;highlighter-rouge&quot;&gt;xxx.param&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;xxx.bin&lt;/code&gt;)了，接下来就是如何使用ncnn模型的问题了。&lt;/p&gt;

&lt;h3 id=&quot;为ncnn添加textboxes算法实现部分&quot;&gt;为ncnn添加TextBoxes算法实现部分&lt;/h3&gt;

&lt;p&gt;  先找到priorbox层的&lt;code class=&quot;highlighter-rouge&quot;&gt;load_param&lt;/code&gt;，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;denser_prior_boxes = pd.get(14, 0);&lt;/code&gt;（别忘了在的.h文件中初始化），再找到detectionoutput层的&lt;code class=&quot;highlighter-rouge&quot;&gt;load_param&lt;/code&gt;，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;use_polygon = pd.get(5, 0);&lt;/code&gt; 接下来就可以开始将Textboxes_plusplus的算法移植到ncnn上了。Priorbox层比较好修改，就不写了。&lt;/p&gt;

&lt;p&gt;  Detectionoutput层需要修改的地方如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;添加Polygon的decode。&lt;/li&gt;
  &lt;li&gt;对bbox添加一个序号以便追踪，这样可以在最后输出时输出对应的polygon，因为polygon不进行nms和sort。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  看着简单，实现起来确实也简单，polygon的decode是算法的核心，具体caffe的实现集成在TextBoxes_plusplus中的detection_output层里的&lt;code class=&quot;highlighter-rouge&quot;&gt;DecodeAllBoxes&lt;/code&gt;函数中，一层层点进去就可以看到这部分的算法代码了，一步步将它从caffe翻译过来就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//detectionoutput,cpp
//DecodeAllBoxes中翻译出来的polygon的decode
if (use_polygon)
{
    #pragma omp parallel for
    for (int i = 0; i &amp;lt; num_prior; i++)
    {
        const float* loc = location_ptr + i * 12;
        const float* pb = priorbox_ptr + i * 4;
        const float* var = variance_ptr + i * 4;

        float* bbox = bboxes.row(i);

        // CENTER_SIZE
        float pb_w = pb[2] - pb[0];
        float pb_h = pb[3] - pb[1];
        float pb_cx = (pb[0] + pb[2]) * 0.5f;
        float pb_cy = (pb[1] + pb[3]) * 0.5f;

        float bbox_cx = var[0] * loc[0] * pb_w + pb_cx;
        float bbox_cy = var[1] * loc[1] * pb_h + pb_cy;
        float bbox_w = exp(var[2] * loc[2]) * pb_w;
        float bbox_h = exp(var[3] * loc[3]) * pb_h;

        bbox[0] = bbox_cx - bbox_w * 0.5f;
        bbox[1] = bbox_cy - bbox_h * 0.5f;
        bbox[2] = bbox_cx + bbox_w * 0.5f;
        bbox[3] = bbox_cy + bbox_h * 0.5f;
                
        PolygonRect polygon;
        polygon.x1 = var[0] * loc[4]  * pb_w + pb[0];
        polygon.y1 = var[1] * loc[5]  * pb_h + pb[1];
        polygon.x2 = var[0] * loc[6]  * pb_w + pb[2];
        polygon.y2 = var[1] * loc[7]  * pb_h + pb[1];
        polygon.x3 = var[0] * loc[8]  * pb_w + pb[2];
        polygon.y3 = var[1] * loc[9]  * pb_h + pb[3];
        polygon.x4 = var[0] * loc[10] * pb_w + pb[0];
        polygon.y4 = var[1] * loc[11] * pb_h + pb[3];
        all_loc_preds_polygon[i] = polygon;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  然后是第二步，因为caffe在&lt;code class=&quot;highlighter-rouge&quot;&gt;keep_nms_k&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;keep_top_k&lt;/code&gt;中是提取每个bbox的index保存下来，然后最后根据index来输出bbox和polygon，而ncnn不是，ncnn是直接舍弃掉了不需要的bbox，没有使用index，所以就无法直接输出与要输出的bbox相匹配的polygon，所以需要对bbox添加一个序号，类似于caffe的index(indices)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//detecionoutput.cpp
for (int j = 0; j &amp;lt; num_prior; j++)
{
    float score = confidence[j * num_class + i];

    if (score &amp;gt; confidence_threshold)
    {
        const float* bbox = bboxes.row(j);
        BBoxRect c = { bbox[0], bbox[1], bbox[2], bbox[3], i, j };
        class_bbox_rects.push_back(c);
        class_bbox_scores.push_back(score);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  这样ncnn基本可以运行 Textboxes_plusplus 的TextBoxes部分了，但是可能还是会有一个问题，这个问题我也是调了好久才发现。本来以为是ncnn的长方形卷积有问题，一步步看下来发现原来是 caffe2ncnn.cpp 中没有把网络的 pad_h 和 pad_w 转进来，所以如果你也有这个问题，不妨去看看 caffe2ncnn.cpp 的 convolution 转参数部分。&lt;/p&gt;

&lt;p&gt;  大功告成&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-03-31-TextBoxes_ncnn/test.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;

&lt;p&gt;  模型转完了，也可以使用了，似乎一切都结束了，但是其实下面还有一个难点，就是你要怎么给不规则四边形施加nms。已知2个四边形共8个点坐标，如何计算它俩的iou？具体可以看我下一篇博客&lt;/p&gt;

&lt;p&gt;  如果有需要，可以参考我的代码，&lt;a href=&quot;https://github.com/FreshMOU/ncnn&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/TextBoxes_in_ncnn/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/TextBoxes_in_ncnn/</guid>
        
        <category>深度学习</category>
        
        
      </item>
    
  </channel>
</rss>
